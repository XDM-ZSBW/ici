<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ICI App</title>
    <style>
        .offline {
            background-color: #f8d7da;
            color: #721c24;
        }
    </style>
</head>
<body>
    <h1>ICI {{ build_version if build_version is defined else '' }}</h1>
    <p id="app-description">This app is designed to demonstrate continuous integration and deployment.</p>
    <p>Data from server: <span id="data-from-server"></span></p>
    <textarea id="env-box" style="width:100%;height:80px;" placeholder="Shared for all clients with the same env-id"></textarea>
    <br>
    <textarea id="client-box" style="width:100%;height:40px;" placeholder="Shared for all with the same public IP and env-id"></textarea>
    <br>
    <textarea id="private-box" style="width:100%;height:40px;" placeholder="Private for this browser, env-id, and public IP"></textarea>
    <br>
    {% if env_id is defined %}
    <script type="text/javascript">
      window.env_id_from_server = "{{ env_id }}";
    </script>
    {% endif %}
    <script>
    // Fetch public IP using a public API
    function fetchPublicIp() {
        return fetch('https://api.ipify.org?format=json').then(r => r.json()).then(d => d.ip);
    }
    // Use env_id from server if available, otherwise fetch
    var envIdFromServer = window.env_id_from_server || null;
    function fetchEnvId() {
        if (envIdFromServer) {
            return Promise.resolve(envIdFromServer);
        }
        return fetch('/env-id').then(r => r.json()).then(d => d.env_id);
    }
    // Generate or retrieve a persistent private client ID for this env-id and public IP
    function getPrivateClientId(envId, publicIp) {
        const storageKey = 'private-client-id-' + envId + '-' + publicIp;
        let clientId = localStorage.getItem(storageKey);
        if (!clientId) {
            clientId = Math.random().toString(16).slice(2) + Date.now().toString(16);
            localStorage.setItem(storageKey, clientId);
        }
        return clientId;
    }
    // Key helpers
    function getEnvBoxKey(envId) {
        return 'env-box-' + envId;
    }
    function getClientBoxKey(envId, publicIp) {
        return 'client-box-' + envId + '-' + publicIp;
    }
    function getPrivateBoxKey(envId, publicIp, privateClientId) {
        return 'private-box-' + envId + '-' + publicIp + '-' + privateClientId;
    }
    function debounce(func, wait) {
        let timeout;
        return function(...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), wait);
        };
    }
    Promise.all([fetchEnvId(), fetchPublicIp()]).then(([envId, publicIp]) => {
    const privateClientId = getPrivateClientId(envId, publicIp);
    // Env-box (shared across all clients with same env-id)
    const envBox = document.getElementById('env-box');
    // Add a hidden textbox for offline preservation
    let envBoxHidden = document.createElement('textarea');
    envBoxHidden.style.display = 'none';
    envBox.parentNode.insertBefore(envBoxHidden, envBox.nextSibling);
    let isEditingEnvBox = false;
    let envBoxPendingSync = false;
    let envBoxLastServerValue = null;
    let envBoxOfflineQueue = [];
    let envBoxServerOnline = true;
    function setEnvBoxDisabled(disabled) {
        envBox.disabled = disabled;
        if (disabled) {
            envBox.classList.add('offline');
            // Copy value to hidden textbox
            envBoxHidden.value = envBox.value;
        } else {
            envBox.classList.remove('offline');
            // Restore value from hidden textbox if it exists
            if (envBoxHidden.value !== undefined && envBoxHidden.value !== null && envBoxHidden.value !== "") {
                envBox.value = envBoxHidden.value;
            }
        }
    }
    function loadEnvBox() {
        fetch('/env-box').then(r => r.json()).then(d => {
            const wasOffline = !envBoxServerOnline;
            envBoxServerOnline = true;
            setEnvBoxDisabled(false);
            envBoxLastServerValue = d.value !== undefined && d.value !== null && d.value !== "" ? d.value : envId;
            if (wasOffline && envBoxOfflineQueue.length > 0) {
                // Merge: client changes first, then server value
                let merged = envBoxOfflineQueue.join('\n') + (envBoxLastServerValue ? ('\n' + envBoxLastServerValue) : '');
                envBox.value = merged;
                fetch('/env-box', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({value: merged})
                }).then(() => {
                    envBoxOfflineQueue = [];
                    envBoxPendingSync = false;
                });
            } else if (wasOffline && envBoxOfflineQueue.length === 0) {
                // If we were offline but no changes were queued, preserve the current value
                // Do not overwrite the textbox
            } else if (!wasOffline && !isEditingEnvBox && !envBoxPendingSync) {
                // Only update the textbox if not editing and not pending sync, and not just coming back online
                envBox.value = envBoxLastServerValue;
            }
        }).catch(() => {
            envBoxServerOnline = false;
            setEnvBoxDisabled(true);
            // Show last known value
            if (envBoxLastServerValue !== null) {
                envBox.value = envBoxLastServerValue;
            } else {
                envBox.value = envId;
            }
        });
    }
    // Set default value if empty
    if (!envBox.value) envBox.value = envId;
    envBox.addEventListener('focus', function() { isEditingEnvBox = true; });
    envBox.addEventListener('blur', function() { isEditingEnvBox = false; });
    envBox.addEventListener('input', debounce(function() {
        if (envBoxServerOnline) {
            fetch('/env-box', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({value: envBox.value})
            }).then(() => {
                envBoxPendingSync = false;
            }).catch(() => {
                envBoxPendingSync = true;
                envBoxOfflineQueue.push(envBox.value);
            });
        } else {
            envBoxOfflineQueue.push(envBox.value);
        }
    }, 400));
    loadEnvBox();
    setInterval(loadEnvBox, 2000);
    // Client-box (shared for all with same public IP and env-id, server API)
    const clientBox = document.getElementById('client-box');
    // Add a hidden textbox for offline preservation
    let clientBoxHidden = document.createElement('textarea');
    clientBoxHidden.style.display = 'none';
    clientBox.parentNode.insertBefore(clientBoxHidden, clientBox.nextSibling);
    let isEditingClientBox = false;
    let clientBoxPendingSync = false;
    let clientBoxLastServerValue = null;
    let clientBoxOfflineQueue = [];
    let clientBoxServerOnline = true;
    function setClientBoxDisabled(disabled) {
        clientBox.disabled = disabled;
        if (disabled) {
            clientBox.classList.add('offline');
            // Copy value to hidden textbox
            clientBoxHidden.value = clientBox.value;
        } else {
            clientBox.classList.remove('offline');
            // Restore value from hidden textbox if it exists
            if (clientBoxHidden.value !== undefined && clientBoxHidden.value !== null && clientBoxHidden.value !== "") {
                clientBox.value = clientBoxHidden.value;
            }
        }
    }
    function loadClientBox() {
        fetch(`/client-box?env_id=${encodeURIComponent(envId)}&public_ip=${encodeURIComponent(publicIp)}`)
          .then(r => r.json()).then(d => {
            const wasOffline = !clientBoxServerOnline;
            clientBoxServerOnline = true;
            setClientBoxDisabled(false);
            clientBoxLastServerValue = d.value !== undefined && d.value !== null && d.value !== "" ? d.value : publicIp;
            if (wasOffline && clientBoxOfflineQueue.length > 0) {
                // Merge: client changes first, then server value
                let merged = clientBoxOfflineQueue.join('\n') + (clientBoxLastServerValue ? ('\n' + clientBoxLastServerValue) : '');
                clientBox.value = merged;
                fetch('/client-box', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({env_id: envId, public_ip: publicIp, value: merged})
                }).then(() => {
                    clientBoxOfflineQueue = [];
                    clientBoxPendingSync = false;
                });
            } else if (wasOffline && clientBoxOfflineQueue.length === 0) {
                // If we were offline but no changes were queued, preserve the current value
                // Do not overwrite the textbox
            } else if (!wasOffline && !isEditingClientBox && !clientBoxPendingSync) {
                // Only update the textbox if not editing and not pending sync, and not just coming back online
                clientBox.value = clientBoxLastServerValue;
            }
        }).catch(() => {
            clientBoxServerOnline = false;
            setClientBoxDisabled(true);
            // Show last known value
            if (clientBoxLastServerValue !== null) {
                clientBox.value = clientBoxLastServerValue;
            } else {
                clientBox.value = publicIp;
            }
        });
    }
    // Set default value if empty
    if (!clientBox.value) clientBox.value = publicIp;
    clientBox.addEventListener('focus', function() { isEditingClientBox = true; });
    clientBox.addEventListener('blur', function() { isEditingClientBox = false; });
    clientBox.addEventListener('input', debounce(function() {
        if (clientBoxServerOnline) {
            fetch('/client-box', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({env_id: envId, public_ip: publicIp, value: clientBox.value})
            }).then(() => {
                clientBoxPendingSync = false;
            }).catch(() => {
                clientBoxPendingSync = true;
                clientBoxOfflineQueue.push(clientBox.value);
            });
        } else {
            clientBoxOfflineQueue.push(clientBox.value);
        }
    }, 400));
    loadClientBox();
    setInterval(loadClientBox, 2000);
    // Private-box (private for this browser, env-id, and public IP)
    const privateBox = document.getElementById('private-box');
    const privateBoxKey = getPrivateBoxKey(envId, publicIp, privateClientId);
    // Helper to get all values
    function getAllBoxValues() {
        return {
            envBox: envBox.value,
            clientBox: clientBox.value,
            privateBox: privateBox.value
        };
    }
    // Helper to set all values
    function setAllBoxValues(obj) {
        if (obj.envBox !== undefined) envBox.value = obj.envBox;
        if (obj.clientBox !== undefined) clientBox.value = obj.clientBox;
        if (obj.privateBox !== undefined) privateBox.value = obj.privateBox;
    }
    // Load from privateBox (client-id textbox) if present
    let storedJson = localStorage.getItem(privateBoxKey);
    if (storedJson) {
        try {
            let obj = JSON.parse(storedJson);
            setAllBoxValues(obj);
        } catch (e) {}
    }
    // Save all values to privateBox (client-id textbox) on any change
    function saveAllToPrivateBox() {
        const obj = getAllBoxValues();
        const json = JSON.stringify(obj);
        privateBox.value = json;
        localStorage.setItem(privateBoxKey, json);
    }
    envBox.addEventListener('input', debounce(saveAllToPrivateBox, 400));
    clientBox.addEventListener('input', debounce(saveAllToPrivateBox, 400));
    privateBox.addEventListener('input', debounce(saveAllToPrivateBox, 400));
    // Also save on load
    saveAllToPrivateBox();
    // On load, if the server returns an empty value for envBox or clientBox, restore from privateBox JSON if available
    function restoreFromPrivateBoxIfServerEmpty() {
        let storedJson = localStorage.getItem(privateBoxKey);
        if (storedJson) {
            try {
                let obj = JSON.parse(storedJson);
                if (obj.envBox && (!envBox.value || envBox.value === envId)) {
                    envBox.value = obj.envBox;
                    // Push to server
                    fetch('/env-box', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({value: obj.envBox})
                    });
                }
                if (obj.clientBox && (!clientBox.value || clientBox.value === publicIp)) {
                    clientBox.value = obj.clientBox;
                    // Push to server
                    fetch('/client-box', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({env_id: envId, public_ip: publicIp, value: obj.clientBox})
                    });
                }
            } catch (e) {}
        }
    }
    // After loading from server, if empty, restore from privateBox
    setTimeout(restoreFromPrivateBoxIfServerEmpty, 1500);
});
    </script>
</body>
</html>
