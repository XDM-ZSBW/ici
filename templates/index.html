<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ICI App</title>
    <style>
        .offline {
            background-color: #f8d7da;
            color: #721c24;
        }
    </style>
</head>
<body>
    <h1>ICI {{ build_version if build_version is defined else '' }}</h1>
    <p id="app-description">This app is designed to demonstrate continuous integration and deployment.</p>
    <p>Data from server: <span id="data-from-server"></span></p>
    <textarea id="env-box" style="width:100%;height:80px;" placeholder="Shared for all clients with the same env-id"></textarea>
    <br>
    <textarea id="client-box" style="width:100%;height:40px;" placeholder="Shared for all with the same public IP and env-id"></textarea>
    <br>
    <textarea id="private-box" style="width:100%;height:40px;" placeholder="Private for this browser, env-id, and public IP"></textarea>
    <br>
    {% if env_id is defined %}
    <script type="text/javascript">
      window.env_id_from_server = "{{ env_id }}";
    </script>
    {% endif %}
    <script>
    // Fetch public IP using a public API
    function fetchPublicIp() {
        return fetch('https://api.ipify.org?format=json').then(r => r.json()).then(d => d.ip);
    }
    // Use env_id from server if available, otherwise fetch
    var envIdFromServer = window.env_id_from_server || null;
    function fetchEnvId() {
        if (envIdFromServer) {
            return Promise.resolve(envIdFromServer);
        }
        return fetch('/env-id').then(r => r.json()).then(d => d.env_id);
    }
    // Generate or retrieve a persistent private client ID for this env-id and public IP
    function getPrivateClientId(envId, publicIp) {
        const storageKey = 'private-client-id-' + envId + '-' + publicIp;
        let clientId = localStorage.getItem(storageKey);
        if (!clientId) {
            clientId = Math.random().toString(16).slice(2) + Date.now().toString(16);
            localStorage.setItem(storageKey, clientId);
        }
        return clientId;
    }
    // Key helpers
    function getEnvBoxKey(envId) {
        return 'env-box-' + envId;
    }
    function getClientBoxKey(envId, publicIp) {
        return 'client-box-' + envId + '-' + publicIp;
    }
    function getPrivateBoxKey(envId, publicIp, privateClientId) {
        return 'private-box-' + envId + '-' + publicIp + '-' + privateClientId;
    }
    function debounce(func, wait) {
        let timeout;
        return function(...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), wait);
        };
    }
    Promise.all([fetchEnvId(), fetchPublicIp()]).then(([envId, publicIp]) => {
    const privateClientId = getPrivateClientId(envId, publicIp);
    // Env-box (shared across all clients with same env-id)
    const envBox = document.getElementById('env-box');
    let isEditingEnvBox = false;
    let envBoxPendingSync = false;
    let envBoxLastServerValue = null;
    let envBoxOfflineQueue = [];
    let envBoxServerOnline = true;
    function setEnvBoxDisabled(disabled) {
        envBox.disabled = disabled;
        if (disabled) {
            envBox.classList.add('offline');
        } else {
            envBox.classList.remove('offline');
        }
    }
    function loadEnvBox() {
        fetch('/env-box').then(r => r.json()).then(d => {
            const wasOffline = !envBoxServerOnline;
            envBoxServerOnline = true;
            setEnvBoxDisabled(false);
            envBoxLastServerValue = d.value !== undefined && d.value !== null && d.value !== "" ? d.value : envId;
            // Only merge and update the textbox if we were offline and have queued changes
            if (wasOffline && envBoxOfflineQueue.length > 0) {
                // Merge: client changes first, then server value
                let merged = envBoxOfflineQueue.join('\n') + (envBoxLastServerValue ? ('\n' + envBoxLastServerValue) : '');
                envBox.value = merged;
                fetch('/env-box', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({value: merged})
                }).then(() => {
                    envBoxOfflineQueue = [];
                    envBoxPendingSync = false;
                });
            } else if (wasOffline && envBoxOfflineQueue.length === 0) {
                // If we were offline but no changes were queued, preserve the current value
                // Do not overwrite the textbox
            } else if (!isEditingEnvBox && !envBoxPendingSync) {
                // Only update the textbox if not editing and not pending sync, and not just coming back online
                envBox.value = envBoxLastServerValue;
            }
        }).catch(() => {
            envBoxServerOnline = false;
            setEnvBoxDisabled(true);
            // Show last known value
            if (envBoxLastServerValue !== null) {
                envBox.value = envBoxLastServerValue;
            } else {
                envBox.value = envId;
            }
        });
    }
    // Set default value if empty
    if (!envBox.value) envBox.value = envId;
    envBox.addEventListener('focus', function() { isEditingEnvBox = true; });
    envBox.addEventListener('blur', function() { isEditingEnvBox = false; });
    envBox.addEventListener('input', debounce(function() {
        if (envBoxServerOnline) {
            fetch('/env-box', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({value: envBox.value})
            }).then(() => {
                envBoxPendingSync = false;
            }).catch(() => {
                envBoxPendingSync = true;
                envBoxOfflineQueue.push(envBox.value);
            });
        } else {
            envBoxOfflineQueue.push(envBox.value);
        }
    }, 400));
    loadEnvBox();
    setInterval(loadEnvBox, 2000);
    // Client-box (shared for all with same public IP and env-id, server API)
    const clientBox = document.getElementById('client-box');
    let isEditingClientBox = false;
    let clientBoxPendingSync = false;
    let clientBoxLastServerValue = null;
    let clientBoxOfflineQueue = [];
    let clientBoxServerOnline = true;
    function setClientBoxDisabled(disabled) {
        clientBox.disabled = disabled;
        if (disabled) {
            clientBox.classList.add('offline');
        } else {
            clientBox.classList.remove('offline');
        }
    }
    function loadClientBox() {
        fetch(`/client-box?env_id=${encodeURIComponent(envId)}&public_ip=${encodeURIComponent(publicIp)}`)
          .then(r => r.json()).then(d => {
            const wasOffline = !clientBoxServerOnline;
            clientBoxServerOnline = true;
            setClientBoxDisabled(false);
            clientBoxLastServerValue = d.value !== undefined && d.value !== null && d.value !== "" ? d.value : publicIp;
            // Only merge and update the textbox if we were offline and have queued changes
            if (wasOffline && clientBoxOfflineQueue.length > 0) {
                // Merge: client changes first, then server value
                let merged = clientBoxOfflineQueue.join('\n') + (clientBoxLastServerValue ? ('\n' + clientBoxLastServerValue) : '');
                clientBox.value = merged;
                fetch('/client-box', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({env_id: envId, public_ip: publicIp, value: merged})
                }).then(() => {
                    clientBoxOfflineQueue = [];
                    clientBoxPendingSync = false;
                });
            } else if (wasOffline && clientBoxOfflineQueue.length === 0) {
                // If we were offline but no changes were queued, preserve the current value
                // Do not overwrite the textbox
            } else if (!isEditingClientBox && !clientBoxPendingSync) {
                // Only update the textbox if not editing and not pending sync, and not just coming back online
                clientBox.value = clientBoxLastServerValue;
            }
        }).catch(() => {
            clientBoxServerOnline = false;
            setClientBoxDisabled(true);
            // Show last known value
            if (clientBoxLastServerValue !== null) {
                clientBox.value = clientBoxLastServerValue;
            } else {
                clientBox.value = publicIp;
            }
        });
    }
    // Set default value if empty
    if (!clientBox.value) clientBox.value = publicIp;
    clientBox.addEventListener('focus', function() { isEditingClientBox = true; });
    clientBox.addEventListener('blur', function() { isEditingClientBox = false; });
    clientBox.addEventListener('input', debounce(function() {
        if (clientBoxServerOnline) {
            fetch('/client-box', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({env_id: envId, public_ip: publicIp, value: clientBox.value})
            }).then(() => {
                clientBoxPendingSync = false;
            }).catch(() => {
                clientBoxPendingSync = true;
                clientBoxOfflineQueue.push(clientBox.value);
            });
        } else {
            clientBoxOfflineQueue.push(clientBox.value);
        }
    }, 400));
    loadClientBox();
    setInterval(loadClientBox, 2000);
    // Private-box (private for this browser, env-id, and public IP)
    const privateBox = document.getElementById('private-box');
    const privateBoxKey = getPrivateBoxKey(envId, publicIp, privateClientId);
    function updatePrivateBoxFromStorage() {
        let privateBoxValue = localStorage.getItem(privateBoxKey);
        privateBox.value = (privateBoxValue !== undefined && privateBoxValue !== null && privateBoxValue !== "") ? privateBoxValue : privateClientId;
    }
    updatePrivateBoxFromStorage();
    window.addEventListener('storage', function(e) {
        if (e.key === privateBoxKey) {
            updatePrivateBoxFromStorage();
        }
    });
    privateBox.addEventListener('input', debounce(function() {
        localStorage.setItem(privateBoxKey, privateBox.value);
    }, 400));
});
    </script>
</body>
</html>
